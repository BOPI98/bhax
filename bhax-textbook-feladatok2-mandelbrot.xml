<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>3. hét - „Helló, Mandelbrot!”</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Reverse engineering UML osztálydiagram</title>
        <para>
           

        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:    
            
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Forward engineering UML osztálydiagram
</title>
        <para>
            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>       
    
    <section>
        <title>Egy esettan
</title>
        <para>
           BME C++ könyv 14. fejezet (427-444,445-469)
        </para>
        <para>
            Ebben a fejezetben az UML és a C++ kapcsolata lesz tárgyalva. Az UML egy általános 
            nyev, amely jelenleg minden fejlesztési nyelv szabványa, ezáltal minden eszközt támogat.
            Az UML nem csak objektumorientált programokról tud modelt készíteni. Az UML egy 
            grafikus modellezőnyelv, melyben a diagramok dobozokból, vonalakból, ikonokból
            és szövegekből állnak. Ennek a grafikonnak az a lényege, hogy egy tömör vázat
            kapjunk az adott programról. Ez a grafikus megjelenítés, akkor hasznos, mikor
            egy problémát magas szinten akarunk megoldani és nem szeretnénk a részleteket 
            figyelembe venni. 
            Az osztálydiagramm legfontosabb alkotóelemei az osztályok, melyeket téglalap 
            jelöl. Ennek 3 fő szakasza van: az osztálynév a legfelső, az attribútumok 
            a középső, a műveletek pedig a legalsó szakaszban vannak. Az attribútumok a
            tagváltozóknak, a műveletek pedig a függvényeknek felelnek meg. 
            Az osztály attribútumait ezzel a szintaxissal adjuk meg: láthatóság név: típus 
            multiplicitás = alapértelmezett érték{tulajdonság}. A láthatóságot  négy féleképpen
            lehet megadni, lehet public, private, protected és package, viszont az utóbbi 
            a c++ nyelvben nem lehetséges. A név és a láthatóság között elhelyezett / jel 
            származtatott attribútumot jelöl. Ha egy programban más változókból származtatik 
            egy változó értéke, akkor azt a c++ kódban nem jelöljük. Ez akkor fontos ha egy 
            osztály egy objektumát relációs adatbázisban szeretnénk tárolni, ahol a lekérdezés során 
            számoljuk ki az értéket. Ha tömb az attribútum akkor a tartalmazott elemek lehetséges számának a 
            halmazát a multiplicitás adja meg. A multiplicitás egy szám vagy egy egészekből álló 
            intrvallum, melyek szövegként megjeleníthetőek. Az alapértelmezett értéke egy.
            Paramétereknél ha nem írunk értéket akkor az in az alapértelmezett. Az in 
            az érték szerinti paraméterátadásnak felel meg, az inout jelentése, hogy a függvény 
            felhasználja a referencia vagy pointer által jelzett objektumot, majd megváltoztatja azt.
            Az out esetében csak megváltoztatja az objektumot. A statikus műveletek aláhúzással 
            vannak jelölve, a tisztán virtuális függvényeket dőlt betűvel vagy {abstract} 
            tulajdonsággal adjuk meg. 
             </para>
        
            <para>
            Az egyfajta kapcsolatot üres háromszögfejű nyíllal jelöljük. A szerepnév előtt 
            - jel van, ami a szerepnévből képződő tagváltozó láthatóságát jelzi. A sablonok ki
            kifejezését vagy a példányosítását kétféleképpen lehet lemodellezni. Az 
            egyszerűbb jelölés az osztály neve utén kettősponttal elválasztva feltünteti a példányostást.
            Ezek a modellező eszközök képesek modellből előállítani kódot és fordítva. Amikor
                modellből kódot állítunk elő, azt kódgenerálásnak hívjuk, és amikor kódból 
                modellt azt pedig kódvisszafejtésnek nevezzük. Ezt a két szolgáltatást együtt 
                képirányú generálásnak nevezzük. 
            
          </para>
        
        <para>
        
        </para>
    </section>   
    
    <section>
        <title>BPMN
</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>   
    
    <section>
        <title>BPEL Helló, Világ! - egy visszhang folyamat
</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>   
    
    <section>
        <title>TeX UML

</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>   
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
