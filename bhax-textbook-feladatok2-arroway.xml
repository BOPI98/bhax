<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>1. hét - „Helló, Arroway!”</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá, hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
  Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)

        </para>
        
        <para>
            Megoldás forrása:    <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">linkhttps://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf</link> (16-22 fólia)
            
        </para>
        <para>
            <link xlink:href="https://github.com/BOPI98/prog2_feladatok/blob/master/Main.java">linkhttps://github.com/BOPI98/prog2_feladatok/blob/master/Main.java</link>
        </para>
        <para>
             <link xlink:href="https://github.com/BOPI98/prog2_feladatok/blob/master/PolarGen.java">link</link>
            </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... : A program azt csinálja, hogy generál két számot, és ezek közöl az egyiket 
            eltárolja, a másikat pedig visszaadja. Mivel elsőnek azt vizsgálja, hogy van e már tárolt elem, ezért 
            kell egy "nincsTárolt" boolean(igaz-hamis értékeket tároló változó). Ha van benne elem akkor egy double-ban eltárolja.
            Ennek csak annyi az értelme, hogy nem generál új számot, ha már van egy tárolt. A program objektum orientáltan van megírva,
            ugyanis maga a polargen osztály egy külön "fájlban" van megírva és a main program ezt használja a lefutáshoz.
        </para>
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
            Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java nyelvre, ugyanúgy működjön!
Mutassunk rá, hogy gyakorlatilag a pointereket és referenciákat kell kiirtani és minden máris működik
(erre utal a feladat neve, hogy Java-ban minden referencia, nincs választás, hogy mondjuk egy
attribútum pointer, referencia vagy tagként tartalmazott legyen).
Miután már áttettük Java nyelvre, tegyük be egy Java Servletbe és a böngészőből GET-es kéréssel
(például a böngésző címsorából) kapja meg azt a mintát, amelynek kiszámolja az LZW binfáját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
    <section>
        <title>"Gagyi"</title>
        <para>
            Az ismert formális2
<![CDATA[„while (x <= t && x >= t && t != x);”]]> tesztkérdéstípusra adj a szokásosnál
(miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
értékekkel meg nem! A példát építsd a JDK Integer.java forrására3
, hogy a 128-nál inkluzív objektum
példányokat poolozza!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
    
    <section>
        <title>Yoda</title>
        <para>
            Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
conditions-t! https://en.wikipedia.org/wiki/Yoda_conditions
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/BOPI98/prog2_feladatok/blob/master/Yoda.java"> 
                                          https://github.com/BOPI98/prog2_feladatok/blob/master/Yoda.java</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... : A yoda stílusban íródott kódban az a lényeg, hogy egy kifejezésben 
            meg vannak cserélve a tagok. Általába ez nem a megszokott módon szokott kinézni ezért ilyen érdekes vagy különleges. 
            Az elnevezése a Star Wars univerzumból ismert karakterről kapta a nevét, azért mert ő is hasonlóképpen alkotta a 
            mondatait. A mondatokat mindig tárggyal kezdte és utána az alany állítmányt. Ez a beszédstílusa azonban inkább 
            az angol verzióban érezhető, mivel a magyar nyelvű filmekben más a szinkron. Ennek a stílusnak nem igazán van sok 
            előnye viszont kritikusok szerint elég rosszul olvasható és értelmezhető egy ilyen kód. A 
        </para>
    </section>
    
    <section>
        <title>Kódolás from scratch</title>
        <para>
            Induljunk ki ebből a tudományos közleményből: http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
Ha megakadsz, de csak végső esetben: https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitokjavat/apbs02.html#pi_jegyei (mert ha csak lemásolod, akkor pont az a fejlesztői élmény marad ki,
melyet szeretném, ha átélnél).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... : A BBP vagyis a Bailey-Borwein-Plouffe egy 1995-ben kitalált algoritmus, ami a Pi 
            hexadecimális jegyeinek egy d>0 számjegytől való kiszámolására szolgál. Ez az algoritmus:
            {16dπ} = {4{16dS1} - 2{16dS4} - {16dS5} - {16dS6}}
            A kód:
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
